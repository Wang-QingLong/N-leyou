1，有没有用过linux?你都用它来做什么？

  Linux是一个长时间运行比较稳定的操作系统，所有我们一般会拿它作为服务器 (web,db,app等)。
  Linux本身具有 C的编译环境、我们的一些软件是没有软件包 (redis、nginx等)的，需要在 Linux的C编译环境编译得到软件包。
————————————————
2，说一下linux下面的一下常用命令？

  常用：
  Pwd 获取当前路径   Cd 跳转到目录   Su -u 切换到管理员 等详情看linux命令大全
————————————————
3, 你是使用什么来连接远程的Linux服务器的？

   需要依赖于 Linux服务器安装 ssh服务端，一般这个 ssh服务的端口 22.
   需要依赖于 Linux服务器安装 sftp服务端，一般这个 sftp服务的端口 25.

   使用ssh客户端连接 linux服务器，就有点儿像 windows下面的远程连接。但是 linux通过ssh连接上以后是没有图形界面，全是命令行。
   Putty
   Xshell
   使用sftp客户端来连接 sftp服务端，来上传和下载文件 .(上传安装包，修改了配置文件上传。 )

   Winscp
   xftp

   企业中常用的两种组合 :
        putty+winscp
        Xshell+xftp=xmanager
   graphic

   面试：使用xshell、putty等ssh客户端来连接服务器，使用xftp、winscp等sftp客户端来上传和现在文件。连接和上传、下载必须依赖于服务器的ssh、sftp服务，也就是linux服务器需要启动这两个服务。
————————————————

4,  有没有使用过云主机？

   使用过，在原来的公司，我们没有使用自己的服务器，而是租用阿里的云主机。
   没有使用过，但是有所了解。

  云主机就是一些云服务运营商 (阿里、华为、西部数码、新浪等 )，提供的远程的服务器功能，我们开发者或者企业只需按需付费就可以租用对应的服务器。

  使用ssh和sftp来进行操作。
————————————————
5,  有没有做过数据库优化方面的事情?

   做过mysql数据库的优化、其他数据库类似
  定位：查找、定位慢查询

  优化手段：

  创建索引 :创建合适的索引，我们就可以现在索引中查询，查询到以后直接找对应的记录。(以空间换时间)
  分表:当一张表的数据比较多或者一张表的某些字段的值比较多并且很少使用时，采用水平分表和垂直分表来优化
  读写分离：当一台服务器不能满足需求时，采用读写分离的方式进行集群。
  缓存:使用redis来进行缓存
  一些常用优化技巧

  查找慢查询并定位慢查询？
     在项目自验项目转测试之前，在启动mysql数据库时开启慢查询，并且把执行慢的语句写到日志中，在运行一定时间后。通过查看日志找到慢查询语句。

  要找出项目中的慢 Sql时
  1、关闭数据库服务器 (关闭服务 )
  2、把慢查询记录到日志中
  graphic
  设置慢查询时间
  4、找出日志中的慢查询 SQL
  使用explain 慢查询语句，来详细分析语句的问题.
---
合理的数据库是设计
根据数据库三范式来进行表结构的设计。设计表结构时，就需要考虑如何设计才能更有效的查询。

数据库三范式：
第一范式：数据表中每个字段都必须是不可拆分的最小单元，也就是确保每一列的原子性；
第二范式：满足一范式后，表中每一列必须有唯一性，都必须依赖于主键；
第三范式：满足二范式后，表中的每一列只与主键直接相关而不是间接相关(外键也是直接相关)，字段没有冗余。

注意：没有最好的设计，只有最合适的设计，所以不要过分注重理论。三范式可以作为一个基本依据，不要生搬硬套。

有时候可以根据场景合理地反规范化：
A：分割表。
B：保留冗余字段。当两个或多个表在查询中经常需要连接时，可以在其中一个表上增加若干冗余的字段，以 避免表之间的连接过于频繁，一般在冗余列的数据不经常变动的情况下使用。
C：增加派生列。派生列是由表中的其它多个列的计算所得，增加派生列可以减少统计运算，在数据汇总时可以大大缩短运算时间。

数据库五大约束：
A：PRIMARY key:设置主键约束；
B：UNIQUE：设置唯一性约束，不能有重复值；
C：DEFAULT 默认值约束
D：NOT NULL：设置非空约束，该字段不能为空；
E：FOREIGN key :设置外键约束。

字段类型选择：
A：尽量使用TINYINT、SMALLINT、MEDIUM_INT作为整数类型而非INT，如果非负则加上UNSIGNED
B：VARCHAR的长度只分配真正需要的空间
C：使用枚举或整数代替字符串类型
D：尽量使用TIMESTAMP而非DATETIME
E：单表不要有太多字段，建议在20以内
F：避免使用NULL字段，很难查询优化且占用额外索引空间

3. 系统配置的优化
例如：MySQL数据库my.cnf

4. 硬件优化
更快的IO、更多的内存。一般来说内存越大，对于数据库的操作越好。但是CPU多就不一定了，因为他并不会用到太多的CPU数量，有很多的查询都是单CPU。另外使用高的IO（SSD、RAID），但是IO并不能减少数据库锁的机制。所以说如果查询缓慢是因为数据库内部的一些锁引起的，那么硬件优化就没有什么意义。
————————————————
6,数据库优化之遵循范式？

   数据库表设计时需要遵循方式
   表的范式，是首先符合1NF, 才能满足2NF , 进一步满足3NF
  1NF: 即表的列的具有原子性,不可再分解 ，即列的信息，不能分解 .只要数据库是关系型数据库 (mysql/oracle/db2/sysbase/sql server)，就自动的满足 1NF.关系型数据库中是不允许分割列的。
  2NF:表中的记录是唯一的.通常我们设计一个主键来实现
  3NF:即表中不要有冗余数据 , 就是说，表的信息，如果能够被推导出来，就不应该单独的设计一个字段来存放 .(外键)
  反3NF :没有冗余的数据库未必是最好的数据库，有时为了提高运行效率，就必须降低范式标准，适当保留冗余数据 。具体做法是：  在概念数据模型设计时遵守第三范式，降低范式标准的工作放到物理数据模型设计时考虑。降低范式就是增加字段，允许冗余 。 订单和订单项、相册浏览次数和照片的浏览次数
————————————————
7, 数据库优化之选择合适的存储引擎

在开发中，我们经常使用的存储引擎  myisam / innodb/ memory
MyISAM存储引擎
如果表对事务要求不高，同时是以查询和添加为主的，我们考虑使用 myisam存储引擎 . 比如 bbs(网络论坛) 中的 发帖表，回复表 .

INNODB存储引擎:
对事务要求高，保存的数据都是重要数据，我们建议使用 INNODB,比如订单表，账号表 .

Memory 存储
          我们数据变化频繁，不需要入库，同时又频繁的查询和修改，我们考虑使用 memory, 速度极快 .

问 MyISAM 和 INNODB的区别 (主要)
1. 事务安全  myisam不支持事务而 innodb支持
2. 查询和添加速度  myisam不用支持事务就不用考虑同步锁，查找和添加和添加的速度快
3. 支持全文索引  myisam支持innodb不支持
4. 锁机制  myisam支持表锁而 innodb支持行锁 (事务)
5. 外键 MyISAM 不支持外键，  INNODB支持外键 . (通常不设置外键，通常是在程序中保证数据的一致 )



--设计数据库经验:

第 1 部分 - 设计数据库之前

1.1考察现有环境
1.2定义标准的对象命名规范
1.3在物理实践之前进行逻辑设计
1.4了解你的业务
1.5创建数据字典和 ER 图表

第 2 部分 - 设计数据库表
2.1检查各种变化
2.2采用有意义的字段名
2.3采用常用实体命名机构数据
2.4数据重复需要采用分立的数据表
2.5保持字段名和类型的一致性
2.6仔细选择数字类型
2.7给文本字段留足余量

第 3 部分 - 选择键
3.1使用系统生成的主键
3.2分解字段用于索引
3.3 键设计 4 原则

    * 为关联字段创建外键。
    * 所有的键都必须唯一。
    * 避免使用复合键。
    * 外键总是关联唯一的键字段。

3.4不要用用户的键
3.5可选键(候选键)有时可做主键

第 4 部分 - 保证数据完整性

第 5 部分 - 各种小技巧

————————————————
8,//TODO redis与Memcache区别

Redis和Memcache是目前非常流行的两种NoSql数据库，都可以用于服务端缓存。两者有怎样的差异呢？

- 从实现来看：
  - redis：单线程
  - Memcache：多线程
- 从存储方式来看：
  - redis：支持数据持久化和主从备份，数据更安全
  - Memcache：数据存于内存，没有持久化功能
- 从功能来看：
  - redis：除了基本的k-v 结构外，支持多种其它复杂结构、事务等高级功能
  - Memcache：只支持基本k-v 结构
- 从可用性看：
  - redis：支持主从备份、数据分片、哨兵监控
  - memcache：没有分片功能，需要从客户端支持

可以看出，Redis相比Memcache功能更加强大，支持的数据结构也比较丰富，已经不仅仅是一个缓存服务。而Memcache的功能相对单一。

！！！！

一、缓存处理流程

      前台请求，后台先从缓存中取数据，取到直接返回结果，取不到时从数据库中取，数据库取到更新缓存，并返回结果，数据库也没取到，那直接返回空结果。
————————————————
一些面试问题：Redis缓存击穿问题、缓存雪崩问题。

(一)缓存和数据库间数据一致性问题
分布式环境下（单机就不用说了）非常容易出现缓存和数据库间的数据一致性问题，针对这一点的话，只能说，如果你的项目对缓存的要求是强一致性的，那么请不要使用缓存。我们只能采取合适的策略来降低缓存和数据库间数据不一致的概率，而无法保证两者间的强一致性。

--合适的策略包括: 合适的缓存更新策略，更新数据库后要及时更新缓存、缓存失败时增加重试机制，例如MQ模式的消息队列。

(二)缓存击穿问题

缓存击穿，是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。
理解就是
      缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力

解决办法: 方案1、使用互斥锁排队

      业界比价普遍的一种做法，即根据key获取value值为空时，锁上，从数据库中load数据后再释放锁。若其它线程获取锁失败，则等待一段时间后重试。这里要注意，分布式环境中要使用分布式锁，单机的话用普通的锁（synchronized、Lock）就够了。

       方案2、接口限流与熔断、降级
重要的接口一定要做好限流策略，防止用户恶意刷接口，同时要降级准备，当接口中的某些服务不可用时候，进行熔断，失败快速返回机制。

       方案3、布隆过滤器

bloomfilter就类似于一个hash set，用于快速判某个元素是否存在于集合中，其典型的应用场景就是快速判断一个key是否存在于某容器，不存在就直接返回。布隆过滤器的关键就在于hash算法和容器大小，下面先来简单的实现下看看效果，我这里用guava实现的布隆过滤器：
————————————————
(三)缓存雪崩问题

缓存在同一时间内大量键过期（失效），接着来的一大波请求瞬间都落在了数据库中导致连接异常

方案1、也是像解决缓存穿透一样加锁排队，实现同上;

方案2、建立备份缓存，缓存A和缓存B，A设置超时时间，B不设值超时时间，先从A读缓存，A没有读B，并且更新A缓存和B缓存;

方案3、设置缓存超时时间的时候加上一个随机的时间长度，比如这个缓存key的超时时间是固定的5分钟加上随机的2分钟，酱紫可从一定程度上避免雪崩问题；
————————————————
(四)缓存并发问题
这里的并发指的是多个redis的client同时set key引起的并发问题。其实redis自身就是单线程操作，多个client并发操作，按照先到先执行的原则，先到的先执行，其余的阻塞。当然，另外的解决方案是把redis.set操作放在队列中使其串行化，必须的一个一个执行
————————————————
(五)缓存穿透
缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求，如发起为id为“-1”的数据或id为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大。

解决方案：

接口层增加校验，如用户鉴权校验，id做基础校验，id<=0的直接拦截；
从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击
————————————————
