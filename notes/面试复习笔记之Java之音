1-------Tcp、Http面试指南---------------------------------

     要说http就绕不开tcp,Tcp协议对应传输层，而Http协议对应用层，从本质上看，二者没有可比性，但是http基于tcp协议的。

   传输层
   Tcp协议面向无连接，不管对方有没有收到，如果要得到通知，需要通过应用层
   通用的Tcp和UDP协议

 重点！！！！

 Tcp的三次握手和四次挥手:

三次握手:   客户端-发送带有SYN标志的数据包到服务端       一次握手
           服务端-发送带有SYN/ACK标志的数据包到客户端   二次握手
           客户端-发送带有ACK标志的数据包到服务端       三次握手

四次挥手: 客户端-发送一个FIN，用来关闭客户端到服务器的数据传送
         服务端收到这个FIN，它发回一个ACK，确认序号为收到的序号加1，和SYN一样
         服务器关闭与客户端的连接，发送一个FIN给客户端
         客户端发回ACK报文确认，并将确认序号设置为收到序号加1


HTTP
Http协议是建立在TCP协议基础之上的，当浏览器需要从服务器获取网页数据的时候，会发出一次Http请求。Http会通过TCP建立起一个到服务器的连接通道，当本次请求需要的数据完毕后，Http会立即将TCP连接断开，这个过程是很短的。所以Http连接是一种短连接，是一种无状态的连接。



所谓的无状态，是指浏览器每次向服务器发起请求的时候，不是通过一个连接，而是每次都建立一个新的连接。如果是一个连接的话，服务器进程中就能保持住这个连接并且在内存中记住一些信息状态。而每次请求结束后，连接就关闭，相关的内容就释放了，所以记不住任何状态，成为无状态连接。

HTTP的英文全称：HyperText Transfer Protocol 超文本传输协议

常用的状态码:

--2XX 成功

200 OK，表示从客户端发来的请求在服务器端被正确处理

204 No content，表示请求成功，但响应报文不含实体的主体部分

206 Partial Content，进行范围请求

--3XX 重定向

301 moved permanently，永久性重定向，表示资源已被分配了新的 URL

302 found，临时性重定向，表示资源临时被分配了新的 URL

303 see other，表示资源存在着另一个 URL，应使用 GET 方法定向获取资源

304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况

307 temporary redirect，临时重定向，和302含义相同

--4XX 客户端错误

400 bad request，请求报文存在语法错误

401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息

403 forbidden，表示对请求资源的访问被服务器拒绝

404 not found，表示在服务器上没有找到请求的资源

--5XX 服务器错误

500 internal sever error，表示服务器端在执行请求时发生了错误

503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求

输入url到页面加载都发生了什么事情？

1输入地址

2浏览器查找域名的 IP 地址 这一步包括 DNS 具体的查找过程，包括：浏览器缓存->系统缓存->路由器缓存...

3浏览器向 web 服务器发送一个 HTTP 请求

4服务器的永久重定向响应（从 http://example.com 到 http://www.example.com）

5浏览器跟踪重定向地址

6服务器处理请求

7服务器返回一个 HTTP 响应

8浏览器显示 HTML

9浏览器发送请求获取嵌入在 HTML 中的资源（如图片、音频、视频、CSS、JS等等）

10浏览器发送异步请求


2--------如何停止一个正在运行的线程?---------------------------------

在java中有以下3种方法可以终止正在运行的线程：

 1,使用退出标志，使线程正常退出，也就是当run方法完成后线程终止。

 2,使用stop方法强行终止，但是不推荐这个方法，因为stop和suspend及resume一样都是过期作废的方法。

 3,使用interrupt方法中断线程。

 1. 停止不了的线程
 interrupt()方法的使用效果并不像for+break语句那样，马上就停止循环。调用interrupt方法是在当前线程中打了一个停止标志，并不是真的停止线程。

 2. 判断线程是否停止状态
 Thread.java类中提供了两种方法：

 this.interrupted(): 测试当前线程是否已经中断；

 this.isInterrupted(): 测试线程是否已经中断；

 3------------对Java线程之间通信方式的理解---------------------------

 通信方式

 ①同步

 ②while轮询的方式

 ③wait/notify机制

 ④管道通信


 ①同步
 这里讲的同步是指多个线程通过synchronized关键字这种方式来实现线程间的通信。


 由于线程A和线程B持有同一个MyObject类的对象object，尽管这两个线程需要调用不同的方法，但是它们是同步执行的，比如：线程B需要等待线程A执行完了methodA()方法之后，它才能执行methodB()方法。这样，线程A和线程B就实现了 通信。

 这种方式，本质上就是“共享内存”式的通信。多个线程需要访问同一个共享变量，谁拿到了锁（获得了访问权限），谁就可以执行。

 ②while轮询的方式

 线程A不断地改变条件，线程ThreadB不停地通过while语句检测这个条件是否成立 ，从而实现了线程间的通信。但是这种方式会浪费CPU资源。

 之所以说它浪费资源，是因为JVM调度器将CPU交给线程B执行时，它没做啥“有用”的工作，只是在不断地测试 某个条件是否成立。就类似于现实生活中，某个人一直看着手机屏幕是否有电话来了，而不是：在干别的事情，当有电话来时，响铃通知TA电话来了。

 这种方式还存在另外一个问题：

 轮询的条件的可见性问题，关于内存可见性问题，可参考：JAVA多线程之volatile 与 synchronized 的比较中的第一点“一，volatile关键字的可见性”

 http://www.cnblogs.com/hapjin/p/5492880.html

 线程都是先把变量读取到本地线程栈空间，然后再去再去修改的本地变量。因此，如果线程B每次都在取本地的 条件变量，那么尽管另外一个线程已经改变了轮询的条件，它也察觉不到，这样也会造成死循环。

 ③wait/notify机制

 用到了Object类的 wait() 和 notify() 方法。

 当条件未满足时(list.size() !=5)，线程A调用wait() 放弃CPU，并进入阻塞状态。---不像②while轮询那样占用CPU

 当条件满足时，线程B调用 notify()通知 线程A，所谓通知线程A，就是唤醒线程A，并让它进入可运行状态。

 这种方式的一个好处就是CPU的利用率提高了。

 但是也有一些缺点：比如，线程B先执行，一下子添加了5个元素并调用了notify()发送了通知，而此时线程A还执行；当线程A执行并调用wait()时，那它永远就不可能被唤醒了。因为，线程B已经发了通知了，以后不再发通知了。这说明：通知过早，会打乱程序的执行逻辑。

 ④管道通信
 就是使用java.io.PipedInputStream 和 java.io.PipedOutputStream进行通信

 分布式系统中说的两种通信机制：共享内存机制和消息通信机制。感觉前面的①中的synchronized关键字和②中的while轮询 “属于” 共享内存机制，由于是轮询的条件使用了volatile关键字修饰时，这就表示它们通过判断这个“共享的条件变量“是否改变了，来实现进程间的交流。

 而管道通信，更像消息传递机制，也就是说：通过管道，将一个线程中的消息发送给另一个。