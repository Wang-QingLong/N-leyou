1，Springcloud框架主要的官方组件？

服务治理模块。——Netflix Eureka
负载均衡——Netflix Ribbon  客户侧的软件负载均衡算法。
熔断器——Netflix Hystrix
网关——Netflix Zuul
分布式配置——Spring Cloud Config  配置管理

Spring Cloud Ribbon是一个基于HTTP和TCP的客户端负载均衡工具，它基于Netflix Ribbon实现。

SpringCloud Config提供服务器端和客户端。服务器存储后端的默认实现使用git，因此它轻松支持标签版本的配置环境，以及可以访问用于管理内容的各种工具。

这个还是静态的，得配合Spring Cloud Bus实现动态的配置更新。
————————————————
2，什么是SOA？SOA和微服务架构的区别是什么？他们分别有哪些特点？

   SOA（全称：Service Oriented Architecture），中文意思为 “面向服务的架构”，你可以将它理解为一个架构模型或者一种设计方法，而并不是服务解决方案。其中包含多个服务， 服务之间通过相互依赖或者通过通信机制，来完成相互通信的，最终提供一系列的功能。一个服务通常以独立的形式存在与操作系统进程中。各个服务之间通过网络调用 。

       跟 SOA 相提并论的还有一个 ESB（企业服务总线），简单来说ESB就是一根管道，用来连接各个服务节点。为了集成不同系统，不同协议的服务，ESB 可以简单理解为：它做了消息的转化解释和路由工作，让不同的服务互联互通；

我们将各个应用之间彼此的通信全部去掉，在中间引入一个ESB企业总线，各个服务之间，只需要和ESB进行通信，这个时候，各个应用之间的交互就会变得更加的清晰，业务架构/逻辑等，也会变得很清楚。原本杂乱没有规划的系统，梳理成了一个有规划可治理的系统，在这个过程中，最大的变化，就是引入了ESB企业总线。

SOA 所解决的核心问题 
       1. 系统集成：站在系统的角度，解决企业系统间的通信问 题，把原先散乱、无规划的系统间的网状结构，梳理成规整、可治理的系统间星形结构，这一步往往需要引入 一些产品，比如 ESB、以及技术规范、服务管理规范；这一步解决的核心问题是【有序】

       2. 系统的服务化：站在功能的角度，把业务逻辑抽象成可复用、可组装的服务，通过服务的编排实现业务的快速再生。目的：把原先固有的业务功能转变为通用的业务服务，实现业务逻辑的快速复用；这一步解决的核心问题是【复用】

       3. 业务的服务化：站在企业的角度，把企业职能抽象成可复用、可组装的服务；把原先职能化的企业架构转变为服务化的企业架构，进一步提升企业的对外服务能力；前面两步都是从技术层面来解决系统调用、系统功能复用的问题。第三步，则是以业务驱动把一个 业务单元封装成一项服务。这一步解决的核心问题是 【高效】
-----
  微服务架构其实和SOA架构类似，微服务是在SOA上做的升华。微服务架构重点强调的一个是"业务需要彻底的组件化和服务化"，原有的单个业务系统会拆分为多个可以独立开发、设计、运行的小应用。这样的小应用和其他各个应用之间，相互去协作通信，来完成一个交互和集成，这就是微服务架构。

        组件化：组件表示一个可以独立更换和升级的单元，就以PC机为例，PC中的 CPU、内存、显卡、硬盘一样，独立更换升级而不影响其他单元。如果我们把PC作为组件以服务的方式构建，那么这台PC只需要维护主板和一些必要的外部设备。CPU、内存、硬盘都是以组件方式提供服务，PC需要调用CPU做计算处理，只需要知道CPU这个组件的地址即可。

微服务的特征
       1. 通过服务实现组件化

       2. 按业务能力来划分服务和开发团队

       3. 去中心化

       4. 基础设施自动化（devops、自动化部署）

SOA 和微服务架构的差别 
       1. 微服务去中心化，去掉ESB企业总线。微服务不再强调传统SOA架构里面比较重的ESB企业服务总线，同时SOA的思想进入到单个业务系统内部实现真正的组件化

      2. Docker容器技术的出现，为微服务提供了更便利的条件，比如更小的部署单元，每个服务可以通过类似Node或者Spring Boot等技术跑在自己的进程中。

      3. SOA注重的是系统集成方面，而微服务关注的是完全分离
———————————————
3，Springcloud网关zuul和Gateway的区别，他们分别对应SpringBoot的哪个版本？

Spring Cloud Gateway 是 Spring Cloud Finchley 版推出来的新组件，用来代替服务网关：Zuul。

开源组织

Spring Cloud Gateway 是 Spring Cloud 微服务平台的一个子项目，属于 Spring 开源社区，依赖名叫：spring-cloud-starter-gateway。  https://spring.io/projects/spring-cloud-gateway

Zuul 是 Netflix 公司的开源项目，Spring Cloud 在 Netflix 项目中也已经集成了 Zuul，依赖名叫：spring-cloud-starter-netflix-zuul。  https://github.com/Netflix/zuul
底层实现: https://stackoverflow.com/questions/47092048/how-is-spring-cloud-gateway-different-from-zuul

Zuul构建于 Servlet 2.5，兼容 3.x，使用的是阻塞式的 API，不支持长连接，比如 websockets。另外

Spring Cloud Gateway构建于 Spring 5+，基于 Spring Boot 2.x 响应式的、非阻塞式的 API。同时，它支持 websockets，和 Spring 框架紧密集成，开发体验相对来说十分不错。

性能表现

这个没什么好比的，要比就和 Zuul 2.x 比，Zuul 2.x 在底层上有了很大的改变，使用了异步无阻塞式的 API，性能改善明显，不过现在 Spring Cloud 也没集成 Zuul 2.x，所以就没什么好比的。

如何选择？

本文说的 Zuul 指 Zuul 1.x，Netflix 早就发布了最新的 Zuul 2.x，但 Spring Cloud 貌似没有整合计划，栈长看了下目前最新的包，整合的还是 Zuul 1.x。

据了解，正是因为 Zuul 2.x 的不断跳票，Spring Cloud 才釜底抽薪推出了自己的服务网关：Spring Cloud Gateway，栈长看了下，使用起来比 Zuul 更简单，配置更方便，所以说选 Spring Cloud Gateway 没错，毕竟是 Spring Cloud 亲儿子，不会始乱终弃。
————————————————

4，SpringCloud中的Ribbon和Feign区别？

在业界，一般有两种微服务的实践方法：基于dubbo的微服务架构、基于Spring Cloud的微服务架构。从概念上来讲，Dubbo和Spring Cloud并不能放在一起对比，因为Dubbo仅仅是一个RPC框架，实现Java程序的远程调用，实施服务化的中间件则需要自己开发；而Spring Cloud则是实施微服务的一系列套件，包括：服务注册与发现、断路器、服务状态监控、配置管理、智能路由、一次性令牌、全局锁、分布式会话管理、集群状态管理等。

在国内基于Dubbo实施服务化，刚开始是基于ZooKeeper进行服务注册与发现，现在已经转成使用Etcd。


etcd是CoreOS团队于2013年6月发起的开源项目，它的目标是构建一个高可用的分布式键值(key-value)数据库。etcd内部采用raft协议作为一致性算法，etcd基于Go语言实现。

目前，在Spring cloud 中服务之间通过restful方式调用有两种方式
- restTemplate+Ribbon
- feign

Ribbon
Ribbon 是一个基于 HTTP 和 TCP 客户端的负载均衡器

它可以在客户端配置 ribbonServerList（服务端列表），然后轮询请求以实现均衡负载

它在联合 Eureka 使用时

ribbonServerList 会被 DiscoveryEnabledNIWSServerList 重写，扩展成从 Eureka 注册中心获取服务端列表

同时它也会用 NIWSDiscoveryPing 来取代 IPing，它将职责委托给 Eureka 来确定服务端是否已经启动

Feign
Spring Cloud Netflix 的微服务都是以 HTTP 接口的形式暴露的，所以可以用 Apache 的 HttpClient 或 Spring 的 RestTemplate 去調用

而 Feign 是一個使用起來更加方便的 HTTP 客戶端，它用起來就好像調用本地方法一樣，完全感覺不到是調用的遠程方法

总结起来就是：发布到注册中心的服务方接口，是 HTTP 的，也可以不用 Ribbon 或者 Feign，直接浏览器一样能够访问

只不过 Ribbon 或者 Feign 调用起来要方便一些，最重要的是：它俩都支持软负载均衡

注意：spring-cloud-starter-feign 里面已经包含了 spring-cloud-starter-ribbon（Feign 中也使用了 Ribbon）

从实践上看，采用feign的方式更优雅（feign内部也使用了ribbon做负载均衡）。


拓展: 软负载均衡与硬负载均衡

软负载，顾名思义就是靠软件手段来实现的负载均衡。比如，我上面那么文章中的各种算法。软负载也通常被称为 4层或 7 层负载！
硬负载，就是靠硬件实现的负载均衡，数据包转发功能。常见的就是 F5，这个机器很贵，通常几百万起吧。
软负载又被称为 4 层或者 7 层负载。这是为什么呢？
因为网络分层最开始被人们分为 4 层，后来进化为 OSI 7 层参考模型
4层: TCP/IP参考模型 主机到网络层  网络互连层 传输层 应用层
7层: 主机到网络层(物理层，数据链路层)
     网络互连层(网络层)
     传输层(传输层)
     应用层(会话层 表示层 应用层)

硬负载效率比软负载高。它的原理是把目标 IP 地址改为后台服务器的 ip 地址。硬负载方面，通常有这些负载均衡设备。多链路负载均衡、防火墙负载均衡、服务器负载均衡等。

软负载方面的软件特别多，比如早期阿里章文嵩博士的 LVS，再比如 Nginx 的负载均衡等。通常软负载有这些大的分类技术，http重定向、DNS负载均衡、反向代理负载均衡、IP负载均衡(LVS-NAT)、直接路由(LVS-DR)、IP隧道(LVS-TUN)等技术。
————————————————
5，用Ribbon做负载均衡和用Zuul做负载均衡有什么区别？

zuul也有负载均衡的功能，它是针对外部请求做负载，那客户端ribbon的负载均衡又是怎么一回事？

客户端ribbon的负载均衡，解决的是服务发起方（在Eureka注册的服务）对被调用的服务的负载，比如我们查询商品服务要调用显示库存和商品明细服务，通过商品服务的接口将两个服务组合，可以减少外部应用的请求，比如手机App发起一次请求即可，可以节省网络带宽，也更省电。

ribbon是对服务之间调用做负载，是服务之间的负载均衡，zuul是可以对外部请求做负载均衡。
————————————————
6，解决Feign首次请求失败的三种解决办法是什么？

Spring Cloud中，Feign和Ribbon在整合了Hystrix后，可能会出现首次调用失败的问题，要如何解决该问题呢？

造成该问题的原因

 Hystrix默认的超时时间是1秒，如果超过这个时间尚未响应，将会进入fallback代码。而首次请求往往会比较慢（因为Spring的懒加载机制，要实例化一些类），这个响应时间可能就大于1秒了。知道原因后，我们来总结一下解决方案。解决方案有三种，以feign为例。

方法一
     该配置是让Hystrix的超时时间改为5秒 :   hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds=5000

方法二
     该配置，用于禁用Hystrix的超时时间    hystrix.command.default.execution.timeout.enabled=false

方法三
    该配置，用于索性禁用feign的hystrix。该做法除非一些特殊场景，不推荐使用   feign.hystrix.enabled=false

————————————————
7，启动Redis时出现闪退的解决办法?
 1--重新用原来的免安装的Redis覆盖,原因:修改了RDB持久化和AOF持久化文件
 2--在解压的redis文件夹下新建一个start.bat（window启动一般都是xx.bat）在新建的start.bat文件中加入下面一句话redis-server.exe redis.windows.conf完成之后，保存，双击start.bat即可启动。原因：启动redis需要用到这两个文件。
 3--打开redis.windows.conf文件，最后一行添加maxmemory 209715200 。原因:redis需要大量内存,容易造成能存不够,需要限制内存。
————————————————
8，关于Spring Cloud断容器Hystrix异常的解决方案有哪些？

服务降级
前面两篇文章中，fallbackMethod所描述的函数实际上就是一个备胎，用来实现服务的降级处理，在注解中我们可以通过fallbackMethod属性来指定降级处理的方法名称，在自定义Hystrix请求命令时我们可以通过重写getFallback函数来处理服务降级之后的逻辑。
————————————————
9，SpringCloud启动Eureka报错连接异常时，您将如何处理？
1,springCloud和springBoot版本 差异问题
2,检查你的Eureka的服务模块下的pom文件是否配置版本，一定不要配置版本
  否则会版本冲突，不写版本，他就会默认使用父模板的版本
————————————————
10，SwaggerUI中提交Json数据过大，后台接受不了，您将如何修改代码来处理？//TODO 待解决
————————————————
11，如果一个接口运行性能差，您将会采用哪几种方式，来优化性能？

阿里的接口性能诊断工具Arthas

连接之后输入命令：trace -j 类的完整路径名 方法名

红色标注的是整个方法中最耗时的方法；

min是方法执行最少的时间，max是方法执行最多的时间，total是方法执行的总时间，count是方法执行的次数

--优化方法

1.sql语句优化（mysql数据库）

使用具体的列而不是使用*；

先EXPLAIN分析一下： sql_no_cache:不使用mysql缓存

查看缓存的命令：SHOW VARIABLES LIKE '%cache%';
                             SHOW STATUS LIKE '%qcache%';
如果使用临时表的话，则要设法不用临时表
2.程序优化，根据Arthas提示的方法耗时进行优化，将耗时多的方法针对性优化，同时尽量减少数据库的连接操作。
3.mysql有缓存，相同的sql语句会查询缓存，但是最好还是减少查询相同sql语句。
————————————————
12，如果通过SpringBoot所写的接口，来上传一个附件文件，它最大的容量应该是多少？如果超过这个容量时最大文件，您将用什么方式去完成？

1，在 */.properties或者 */ .yml 配置文件中直接配置
#单个文件大小限制
#spring.http.multipart.maxFileSize = 10Mb
## 总的大小限制，适用于所有MultipartFile文件
##spring.http.multipart.maxRequestSize=100Mb

2，在启动类中配置bean管理也可以


/**
     * 文件上传配置
     * @return
     */
	@Value("${spring.servlet.multipart.max-file-size}")
	private String maxSize;

    @Bean
    public MultipartConfigElement multipartConfigElement() {
        MultipartConfigFactory factory = new MultipartConfigFactory();

        //  单个数据大小
       factory.setMaxFileSize(maxSize); // KB,MB
       /// 总上传数据大小
        factory.setMaxRequestSize("102400KB");
        return factory.createMultipartConfig();
   }
要注意在类中加@configuration 注解，否则不起作用
————————————————
13，如果A表和B表没有建立外键关系，JPA是否支持二表的左连接，如果不支持，但是你想完成此功能，如何实现？
1：使用注解的方法写SQL JPQL(JPQL是面向对象的，是JPA的查询语言)
2：使用QueryDSL进行复杂查询，强烈建议使用QueryDSL(一个能使用静态类型构建类似于SQL的查询的框架)
————————————————
14，什么情况下需要用存储过程？java如何调用存储过程？

第一步

现在在开发中使用存储过程的地方越来越少，但是金融行业还是非常流行，将一些核心业务操作封装在数据库操作中，采用预编译的情况，提高程序的执行速度，防止业务泄露，所以对于存储过程的使用还是需要掌握
第二步

callableStatement主要是通过调用数据库的存储过程，callableStatemt是使用statement接口的子接口，在使用callableStatemnt的时候可以接受过程的返回值
callableStatement的常用方法：
第三步
根据编号取出存储过程的返回值：int getInt(int paramenterIndex ) throws SqlException
根据编号取出过程的返回值：float getFloat(int paramenterIndex) throws SqLException

第四步

建立存储过程，int类型，默认设置，什么都不声明就表示in类型，只是将内容传递进来

inout类型：表示把值传递过程中，并且可以保留存储过程对此值的修改

out :可以不传递内容，存储过程对此值的操作是可以返回的

第五步

主要是了解callablestatemnt,存储过程中的三种类型需要了解：in、inout，out

------何为储存过程？
存储过程（Stored Procedure）是在大型数据库系统中，一组为了完成特定功能的SQL 语句集，它存储在数据库中，一次编译后永久有效，用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。存储过程是数据库中的一个重要对象。在数据量特别庞大的情况下利用存储过程能达到倍速的效率提升

该不该用存储过程？什么情况下使用存储过程？

存储过程能不用尽量不用,原则是:业务逻辑不要封装在数据库里面(数据库去进行逻辑判断业务)。把业务逻辑要交给应用程序处理。这样可以减少数据库资源消耗。
把业务逻辑写到存储过程中不利于系统分层设计和维护，更不利于数据库的迁移。

对于使用存储过程封装业务逻辑的好处，归纳起来有以下几点：

1、  执行速度快。因为存储过程不需要解析。预先编译了

2、  安全性。避免了sql注入，避免了暴露表结构和字段

其实，很多真正提高效率的终极办法是使用缓存而不是在数据库中运算，靠数据库预编译或减少网络流量那点优化就可以，那说明性能要求原本不高。可以去了解google，亚马逊，淘宝网，新浪等是如何做的。像电信他们那样子大量提高硬件治标不治本，而是用分布式代替，就像人，单个人总再强总是存在极限的。所以使用存储过程速度更快，那点速度的提升其实微不足道。根本无法解决本质问题。

总结:
业务逻辑封装在存储过程中，是要看场景使用

一、如果是金融，银行，电信等国企类。使用存储过程影响不大。这种情况是持续了很多年。

好处：

1、银行类系统对于安全性要求很高，存储过程把sql封装起来，完全可以屏蔽sql注入(也不是没替代方案，互联网也有安全性要求比较高的，比如在线支付都可以有其他方式来解决)



2、对系统的速度要求很高。往往是通过花大价钱购买硬件和oracle之类的数据库服务来解决问题，这些企业非常有钱，可以通过花钱购买oracle数据库，良好的硬件来解决。比如一台机子上几百万都可以承受。只要能保证我安全,花钱可以接受。反而在互联网环境下，为了节省成本，互联网大部分公司面对性能瓶颈， 更多使用大量廉价的pc server(一万左右一台)来做集群，从集中式向分布式进行部署。google以前也是使用大量廉价的mysql集群(使用存储过程是没法做到分布式查询,存储过程本来就是在一个库下面)，依赖于某个单个库）。

另外，解决性能瓶颈，互联网大部分还是通过使用缓存来解决的，这跟银行类系统"花费大价钱提高硬件和数据库软件的承载能力"思路是不同的。



从这个角度来说，我其实不觉得电信行业这些人技术多么牛逼。原因在于，他们提高性能的方式其实更多是通过花费大量的钱来购买oracle商业的数据库以及ibm之类的小型中型服务器抗住。通俗说，就是商业公司帮助解决的。
————————————————
15，用JPA和原始的SQL来做数据操纵的区别是什么？//TODO
16，PO,VO,BO的本质区别是什么？如何判断是哪种对象？
PO：persistent object 持久对象
BO：business object 业务对象
VO：value object 值对象 / view object 表现层对象
DTO（TO）：Data Transfer Object 数据传输对象
————————————————

17，Springcloud中异常有哪些类型？处理这些异常的方案有哪些？和传统的处理异常有什么不同？

前后端统一错误格式，需要规定如下：

返回格式：JSON
返回请求状态码：根据不同请求对应的状态码意义返回

2020/1/6
-----------------------
svn如何解决冲突问题？

Spring事务失效的原因:
1,如使用mysql且引擎是MyISAM，则事务会不起作用，原因是MyISAM不支持事务，可以改成InnoDB
2. 如果使用了spring+mvc，则context:component-scan重复扫描问题可能会引起事务失败。
3. @Transactional 注解开启配置，必须放到listener里加载，如果放到DispatcherServlet的配置里，事务也是不起作用的。
4. @Transactional 注解只能应用到 public 可见度的方法上。 如果你在 protected、private 或者 package-visible 的方法上使用 @Transactional 注解，它也不会报错，事务也会失效。
5. Spring团队建议在具体的类（或类的方法）上使用 @Transactional 注解，而不要使用在类所要实现的任何接口上。在接口上使用 @Transactional 注解，只能当你设置了基于接口的代理时它才生效。因为注解是 不能继承 的，这就意味着如果正在使用基于类的代理时，那么事务的设置将不能被基于类的代理所识别，而且对象也将不会被事务代理所包装。

linux命令:

    tail -n 1000：显示最后1000行

    tail -n +1000：从1000行开始显示，显示1000行以后的

    head -n 1000：显示前面1000行



什么是死锁？
所谓死锁，是指多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进。 因此我们举个例子来描述，如果此时有一个线程A，按照先锁a再获得锁b的的顺序获得锁，而在此同时又有另外一个线程B，按照先锁b再锁a的顺序获得锁。

产生死锁的原因？
可归结为如下两点：

 a. 竞争资源

 系统中的资源可以分为两类：
 可剥夺资源，是指某进程在获得这类资源后，该资源可以再被其他进程或系统剥夺，CPU和主存均属于可剥夺性资源；
 另一类资源是不可剥夺资源，当系统把这类资源分配给某进程后，再不能强行收回，只能在进程用完后自行释放，如磁带机、打印机等。
 产生死锁中的竞争资源之一指的是竞争不可剥夺资源（例如：系统中只有一台打印机，可供进程P1使用，假定P1已占用了打印机，若P2继续要求打印机打印将阻塞）
 产生死锁中的竞争资源另外一种资源指的是竞争临时资源（临时资源包括硬件中断、信号、消息、缓冲区内的消息等），通常消息通信顺序进行不当，则会产生死锁
 b. 进程间推进顺序非法

 若P1保持了资源R1,P2保持了资源R2，系统处于不安全状态，因为这两个进程再向前推进，便可能发生死锁
 例如，当P1运行到P1：Request（R2）时，将因R2已被P2占用而阻塞；当P2运行到P2：Request（R1）时，也将因R1已被P1占用而阻塞，于是发生进程死锁
 ————————————————
死锁产生的4个必要条件？
产生死锁的必要条件：

互斥条件：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用。
请求和保持条件：当进程因请求资源而阻塞时，对已获得的资源保持不放。
不剥夺条件：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。
环路等待条件：在发生死锁时，必然存在一个进程--资源的环形链。

预防死锁：
资源一次性分配：一次性分配所有资源，这样就不会再有请求了：（破坏请求条件）
只要有一个资源得不到分配，也不给这个进程分配其他的资源：（破坏请保持条件）
可剥夺资源：即当某进程获得了部分资源，但得不到其它资源，则释放已占有的资源（破坏不可剥夺条件）
资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件
————————————————
解决死锁的基本方法
预防死锁：
资源一次性分配：一次性分配所有资源，这样就不会再有请求了：（破坏请求条件）
只要有一个资源得不到分配，也不给这个进程分配其他的资源：（破坏请保持条件）
可剥夺资源：即当某进程获得了部分资源，但得不到其它资源，则释放已占有的资源（破坏不可剥夺条件）
资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）
1、以确定的顺序获得锁

如果必须获取多个锁，那么在设计的时候需要充分考虑不同线程之前获得锁的顺序。按照上面的例子，两个线程获得锁的时序图如下：



 如果此时把获得锁的时序改成：



 那么死锁就永远不会发生。 针对两个特定的锁，开发者可以尝试按照锁对象的hashCode值大小的顺序，分别获得两个锁，这样锁总是会以特定的顺序获得锁，那么死锁也不会发生。问题变得更加复杂一些，如果此时有多个线程，都在竞争不同的锁，简单按照锁对象的hashCode进行排序（单纯按照hashCode顺序排序会出现“环路等待”），可能就无法满足要求了，这个时候开发者可以使用银行家算法，所有的锁都按照特定的顺序获取，同样可以防止死锁的发生，该算法在这里就不再赘述了，有兴趣的可以自行了解一下。

2、超时放弃

当使用synchronized关键词提供的内置锁时，只要线程没有获得锁，那么就会永远等待下去，然而Lock接口提供了boolean tryLock(long time, TimeUnit unit) throws InterruptedException方法，该方法可以按照固定时长等待锁，因此线程可以在获取锁超时以后，主动释放之前已经获得的所有的锁。通过这种方式，也可以很有效地避免死锁。 还是按照之前的例子，时序图如下：



避免死锁:
预防死锁的几种策略，会严重地损害系统性能。因此在避免死锁时，要施加较弱的限制，从而获得 较满意的系统性能。由于在避免死锁的策略中，允许进程动态地申请资源。因而，系统在进行资源分配之前预先计算资源分配的安全性。若此次分配不会导致系统进入不安全的状态，则将资源分配给进程；否则，进程等待。其中最具有代表性的避免死锁算法是银行家算法。
银行家算法：首先需要定义状态和安全状态的概念。系统的状态是当前给进程分配的资源情况。因此，状态包含两个向量Resource（系统中每种资源的总量）和Available（未分配给进程的每种资源的总量）及两个矩阵Claim（表示进程对资源的需求）和Allocation（表示当前分配给进程的资源）。安全状态是指至少有一个资源分配序列不会导致死锁。当进程请求一组资源时，假设同意该请求，从而改变了系统的状态，然后确定其结果是否还处于安全状态。如果是，同意这个请求；如果不是，阻塞该进程知道同意该请求后系统状态仍然是安全的。
检测死锁
首先为每个进程和每个资源指定一个唯一的号码；
然后建立资源分配表和进程等待表。
解除死锁:
当发现有进程死锁后，便应立即把它从死锁状态中解脱出来，常采用的方法有：

剥夺资源：从其它进程剥夺足够数量的资源给死锁进程，以解除死锁状态；
撤消进程：可以直接撤消死锁进程或撤消代价最小的进程，直至有足够的资源可用，死锁状态.消除为止；所谓代价是指优先级、运行代价、进程的重要性和价值等。

死锁检测
1、Jstack命令

jstack是java虚拟机自带的一种堆栈跟踪工具。jstack用于打印出给定的java进程ID或core file或远程调试服务的Java堆栈信息。 Jstack工具可以用于生成java虚拟机当前时刻的线程快照。线程快照是当前java虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等。 线程出现停顿的时候通过jstack来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做什么事情，或者等待什么资源。

2、JConsole工具

Jconsole是JDK自带的监控工具，在JDK/bin目录下可以找到。它用于连接正在运行的本地或者远程的JVM，对运行在Java应用程序的资源消耗和性能进行监控，并画出大量的图表，提供强大的可视化界面。而且本身占用的服务器内存很小，甚至可以说几乎不消耗。
————————————————
varchar()和char()的区别？

1，char得长度是不可变得 ，而varchar的长度是可变的
2，定义一个char[10]和varchar[10],如果存进去的是‘abcd’，那么char所占的长度依然是10，除了
字符‘abcd’外，后面跟6个空格，而varchar就立马把长度变为4了，
取数据的时候，char类型的要用trim()去掉多余的空格，而varchar是不需要的
3，char的存储数据还是要比varchar要快的多，因为其长度固定，方便程序的存储和查找,但是char也为此付出了空间的代价，可谓以空间换时间，而varchar是以空间效率为首位的
4，char的存储方式是，对英文字符(ASCII)占用1个字节，对汉字占用2个字节，两者的存储数据都非unicode得字符数据
————————————————
多个double型数字运算丢失精度的解决办法

这是因为计算机内部是用的是二进制码，当我们输入float或者double类型的十进制数的时候，会先转化成二进制数再进行运算，最后在转化为十进制输出。然而有些数字不能完全转化成二进制，计算机只能将结果无限趋近于原本十进制的数值，故会出现精度丢失的问题。

这个问题可以使用java提供的BigDecimal类解决


public class Test {

       public static void main(String[] args) {

              // 使用BigDecimal类进行二次处理

              BigDecimal b1 = new BigDecimal(Double.toString(tmp1));

              BigDecimal b2 = new BigDecimal(Double.toString(tmp2));

              double sum2 = b1.add(b2).doubleValue();

              System.out.println(sum2);

       }

}

————————————————








————————————————




分布式CPA理论


————————————————
redis除了用与缓存还能用于做什么

排行榜应用
实现这个功能主要用到的redis数据类型是redis的有序集合zset。zset 是set 类型的一个扩展，比原有的类型多了一个顺序属性，此属性在每次插入数据时会自动调整顺序值,保证value值按照一定顺序连续排列。


计数器应用
Redis的命令都是原子性的，你可以轻松地利用INCR、DECR命令进行原子性操作，来构建计数系统。由于单线程，可以避免并发问题，保证不会出错，而且100%毫秒级性能。

数据排重
Redis set是可以自动排重的，当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口。

实时的反垃圾系统
反垃圾系统通常都是基于关键词的，使用Redis储存关系词，能够利用Redis的高性能，为监控系统提供稳定及精确的实时监控功能，典型的案例如，邮件系统、评论系统等。

可以发布、订阅的实时消息系统
Redis中Pub/Sub系统可以构建实时的消息系统，比如，很多使用Pub/Sub构建的实时聊天应用。

设计思路：

服务端发送消息（含标题，内容），标题按照一定规则存入redis，同时标题（以最少的信息量）推送到客户端，客户点击标题时，获取相应的内容阅读.

如果未读取，可以提示多少条未读，redis能够很快记数

根据一定时间清理缓存

队列应用
队列在现在程序中应用十分广泛，比如日志推送、任务处理等等。以往通常使用http sqs实现队列，其实，使用redis的list类型，也可以实现队列。
————————————————
java中volatile关键字的含义

volatile

用volatile修饰的变量，线程在每次使用变量的时候，都会读取变量修改后的最值。volatile很容易被误用，用来进行原子性操作。

对象的生命周期