微服务
7.1.1. 服务注册发现
服务注册就是维护一个登记簿，它管理系统内所有的服务地址。当新的服务启动后，它会向登记
簿交待自己的地址信息。服务的依赖方直接向登记簿要 Service Provider 地址就行了。
当下用于服务注册的工具非常多 ZooKeeper，Consul，Etcd, 还有 Netflix 家的 eureka 等。服务注册有两种
形式：客户端注册和第三方注册。
7.1.1.1. 客户端注册（zookeeper）
客户端注册是服务自身要负责注册与注销的工作。当服务启动后向注册中心注册自身，当服务下
线时注销自己。期间还需要和注册中心保持心跳。心跳不一定要客户端来做，也可以由注册中心
负责（这个过程叫探活）。这种方式的缺点是注册工作与服务耦合在一起，不同语言都要实现一
套注册逻辑
第三方注册（独立的服务 Registrar）
第三方注册由一个独立的服务Registrar负责注册与注销。当服务启动后以某种方式通知Registrar， 然后 Registrar 负责向注册中心发起注册工作。同时注册中心要维护与服务之间的心跳，当服务不可用时，向注册中心注销服务。这种方式的缺点是 Registrar必须是一个高可用的系统，否则注册工作没法进展。
7.1.1.3. 客户端发现
客户端发现是指客户端负责查询可用服务地址，以及负载均衡的工作。这种方式最方便直接，而
且也方便做负载均衡。再者一旦发现某个服务不可用立即换另外一个，非常直接。缺点也在于多
语言时的重复工作，每个语言实现相同的逻辑。
服务端发现
服务端发现需要额外的 Router 服务，请求先打到 Router，然后 Router 负责查询服务与负载均衡。这种方式虽然没有客户端发现的缺点，但是它的缺点是保证 Router 的高可用。

API 网关
API Gateway 是一个服务器，也可以说是进入系统的唯一节点。这跟面向对象设计模式中的
Facade 模式很像。API Gateway 封装内部系统的架构，并且提供 API 给各个客户端。它还可能有
其他功能，如授权、监控、负载均衡、缓存、请求分片和管理、静态响应处理等。下图展示了一
个适应当前架构的 API Gateway

1.2.1. 请求转发
服务转发主要是对客户端的请求安装微服务的负载转发到不同的服务上
7.1.2.2. 响应合并
把业务上需要调用多个服务接口才能完成的工作合并成一次调用对外统一提供服务。
7.1.2.3. 协议转换
重点是支持 SOAP，JMS，Rest 间的协议转换。
7.1.2.4. 数据转换
重点是支持 XML 和 Json 之间的报文格式转换能力（可选）
13/04/2018 Page 144 of 283
7.1.2.5. 安全认证
1. 基于 Token 的客户端访问控制和安全策略
2. 传输数据和报文加密，到服务端解密，需要在客户端有独立的 SDK 代理包
3. 基于 Https 的传输加密，客户端和服务端数字证书支持
4. 基于 OAuth2.0 的服务安全认证(授权码，客户端，密码模式等）
7.1.3. 配置中心
配置中心一般用作系统的参数配置，它需要满足如下几个要求：高效获取、实时感知、分布式访
问。
7.1.3.1. zookeeper 配置中心
实现的架构图如下所示，采取数据加载到内存方式解决高效获取的问题，借助 zookeeper 的节点
监听机制来实现实时感知。

7.1.4.事件调度（kafka）
消息服务和事件的统一调度，常用用 kafka ，activemq 等。
7.1.5.服务跟踪（starter-sleuth）
随着微服务数量不断增长，需要跟踪一个请求从一个微服务到下一个微服务的传播过程， Spring
Cloud Sleuth 正是解决这个问题，它在日志中引入唯一 ID，以保证微服务调用之间的一致性，这
样你就能跟踪某个请求是如何从一个微服务传递到下一个。
为了实现请求跟踪，当请求发送到分布式系统的入口端点时，只需要服务跟踪框架为该请求
创建一个唯一的跟踪标识，同时在分布式系统内部流转的时候，框架始终保持传递该唯一标
识，直到返回给请求方为止，这个唯一标识就是前文中提到的 Trace ID。通过 Trace ID 的记
录，我们就能将所有请求过程日志关联起来。
2. 为了统计各处理单元的时间延迟，当请求达到各个服务组件时，或是处理逻辑到达某个状态
时，也通过一个唯一标识来标记它的开始、具体过程以及结束，该标识就是我们前文中提到
的 Span ID，对于每个 Span 来说，它必须有开始和结束两个节点，通过记录开始 Span 和结
束 Span 的时间戳，就能统计出该 Span 的时间延迟，除了时间戳记录之外，它还可以包含一
些其他元数据，比如：事件名称、请求信息等。
3. 在快速入门示例中，我们轻松实现了日志级别的跟踪信息接入，这完全归功于spring-cloudstarter-sleuth 组件的实现。在 Spring Boot 应用中，通过在工程中引入 spring-cloudstarter-sleuth 依赖之后， 它会自动的为当前应用构建起各通信通道的跟踪机制，比如：
 通过诸如 RabbitMQ、Kafka（或者其他任何 Spring Cloud Stream 绑定器实现的消息
中间件）传递的请求。  通过 Zuul 代理传递的请求。  通过 RestTemplate 发起的请求

Hystrix 断路器机制
断路器很好理解, 当 Hystrix Command 请求后端服务失败数量超过一定比例(默认 50%), 断路器会
切换到开路状态(Open). 这时所有请求会直接失败而不会发送到后端服务. 断路器保持在开路状态
一段时间后(默认 5 秒), 自动切换到半开路状态(HALF-OPEN). 这时会判断下一次请求的返回情况,
如果请求成功, 断路器切回闭路状态(CLOSED), 否则重新切换到开路状态(OPEN). Hystrix 的断路器
就像我们家庭电路中的保险丝, 一旦后端服务不可用, 断路器会直接切断请求链, 避免发送大量无效
请求影响系统吞吐量, 并且断路器有自我检测并恢复的能力

SwaggerAPI 管理工具。


NIO弥补了原来的I/O的不足，它再标准java代码中提供了高速和面向块的I/O
原力的I/O库与NIO最重要的区别是数据打包和传输方式的不同，原来的I/O以流的方式处理数据，而NIO以块的方式处理数据；
2.NIO以通道channel和缓冲区Buffer为基础来实现面向块的IO数据处理，MINA是开源的。
JavaNIO非堵塞应用通常适用用在I/O读写等方面，我们知道，系统运行的性能瓶颈通常在I/O读写，包括对端口和文件的操作上，过去，在打开一个I/O通道后，read()将一直等待在端口一边读取字节内容，如果没有内容进来，read()也是傻傻的等，这会影响我们程序继续做其他事情，那么改进做法就是开设线程，让线程去等待，但是这样做也是相当耗费资源的。
Java NIO非堵塞技术实际是采取Reactor模式，或者说是Observer模式为我们监察I/O端口，如果有内容进来，会自动通知我们，这样，我们就不必开启多个线程死等，从外界看，实现了流畅的I/O读写，不堵塞了。


8.1.1. Netty 原理
Netty 是一个高性能、异步事件驱动的 NIO 框架，基于 JAVA NIO 提供的 API 实现。它提供了对
TCP、UDP 和文件传输的支持，作为一个异步 NIO 框架，Netty 的所有 IO 操作都是异步非阻塞
的，通过 Future-Listener 机制，用户可以方便的主动获取或者通过通知机制获得 IO 操作结果。
8.1.2. Netty 高性能
在 IO 编程过程中，当需要同时处理多个客户端接入请求时，可以利用多线程或者 IO 多路复用技术
进行处理。IO 多路复用技术通过把多个 IO 的阻塞复用到同一个 select 的阻塞上，从而使得系统在
单线程的情况下可以同时处理多个客户端请求。与传统的多线程/多进程模型比，I/O 多路复用的
最大优势是系统开销小，系统不需要创建新的额外进程或者线程，也不需要维护这些进程和线程
的运行，降低了系统的维护工作量，节省了系统资源。
与 Socket 类和 ServerSocket 类相对应，NIO 也提供了 SocketChannel 和 ServerSocketChannel
两种不同的套接字通道实现。
8.1.2.1. 多路复用通讯方式
Netty 架构按照 Reactor 模式设计和实现，它的服务端通信序列图如下：
客户端通信序列图如下：
13/04/2018 Page 148 of 283
Netty 的 IO 线程 NioEventLoop 由于聚合了多路复用器 Selector，可以同时并发处理成百上千个
客户端 Channel，由于读写操作都是非阻塞的，这就可以充分提升 IO 线程的运行效率，避免由于
频繁 IO 阻塞导致的线程挂起。
8.1.2.1. 异步通讯 NIO
由于 Netty 采用了异步通信模式，一个 IO 线程可以并发处理 N 个客户端连接和读写操作，这从根
本上解决了传统同步阻塞 IO 一连接一线程模型，架构的性能、弹性伸缩能力和可靠性都得到了极
大的提升。
13/04/2018 Page 149 of 283
8.1.2.2. 零拷贝（DIRECT BUFFERS 使用堆外直接内存）
1. Netty 的接收和发送 ByteBuffer 采用 DIRECT BUFFERS，使用堆外直接内存进行 Socket 读写，
不需要进行字节缓冲区的二次拷贝。如果使用传统的堆内存（HEAP BUFFERS）进行 Socket 读写，
JVM 会将堆内存 Buffer 拷贝一份到直接内存中，然后才写入 Socket 中。相比于堆外直接内存，
消息在发送过程中多了一次缓冲区的内存拷贝。
2. Netty 提供了组合 Buffer 对象，可以聚合多个 ByteBuffer 对象，用户可以像操作一个 Buffer 那样
方便的对组合 Buffer 进行操作，避免了传统通过内存拷贝的方式将几个小 Buffer 合并成一个大的
Buffer。
3. Netty的文件传输采用了transferTo方法，它可以直接将文件缓冲区的数据发送到目标Channel，
避免了传统通过循环 write 方式导致的内存拷贝问题
// TODO   待续